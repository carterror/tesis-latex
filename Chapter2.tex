 \chapter{Características y diseño del sistema}
\label{chap:chapter2}

\section{Introducción al capítulo}

En el presente capítulo se presenta una propuesta de solución para los problemas detectados en el estudio
del estado del arte realizado en el Capítulo 1. Se mencionan los roles que intervienen en la solución. También
se definen las HU, la planificación de entrega de versiones del producto y el diseño del sistema de acuerdo a
las fases que propone XP.

\section{Propuesta de solución}

Luego de haber analizado las necesidades del sistema y seleccionado las herramientas para la implementación, se definen los módulos a desarrollar para dar solución al problema planteado.

\begin{itemize}
	\item Autenticación y Autorización: Este módulo se encargaría de gestionar la autenticación de usuarios, el registro de cuentas y la autorización de acceso a diferentes partes de la aplicación.
	\item Gestión de Citas: Este módulo sería el núcleo de la aplicación y se encargaría de permitir a los usuarios programar, modificar y cancelar citas. Debería incluir un calendario interactivo, notificaciones de citas programadas y recordatorios automáticos.
	\item Gestión de Clientes: Aquí se manejaría toda la información relacionada con los clientes, incluyendo su perfil, historial de citas, documentos legalizados y cualquier otra información relevante.
	\item Servicios Legales y Legalización: Este módulo se enfocaría en la gestión de los servicios legales ofrecidos por el bufete de abogados, así como en el proceso de legalización de documentos. Debería permitir a los usuarios solicitar servicios específicos, enviar documentos y realizar seguimiento del estado de sus trámites.
	\item Comunicación y Notificaciones: Este módulo sería responsable de facilitar la comunicación entre el bufete de abogados y sus clientes, a través de mensajes directos, correos electrónicos o notificaciones automáticas sobre el estado de las citas y servicios solicitados.
	\item Administración del Sistema: Este módulo sería utilizado por los administradores del sistema para gestionar usuarios, configurar ajustes de la aplicación, generar informes y realizar tareas de mantenimiento.
	\item Análisis y Reportes: Este módulo se encargaría de recopilar datos sobre el uso de la aplicación, el rendimiento del sistema y la satisfacción del cliente, para generar informes y análisis que ayuden a mejorar la eficiencia y calidad del servicio.
\end{itemize}

Para el desarrollo de los módulos propuestos se siguen los pasos que establece la metodología ágil XP,
donde se respetará el esquema que explica \citep{escribano2002introduccion}.

\section{Fase I: Planificación}

Es la fase en la que se define el alcance general del proyecto. En esta el cliente define lo que necesita
mediante la redacción de HU y establece la prioridad de cada una. Luego, los programadores estiman los
tiempos de desarrollo en base a esta información. Las estimaciones realizadas en esta fase son primarias,
debido a que estarán basadas en datos de muy alto nivel y podrían variar cuando se analicen en cada ite-
ración. Además se toman acuerdos sobre el contenido de la primera entrega y se determina un cronograma
en conjunto con el cliente. Una entrega debería obtenerse en no más de tres meses \citep{escribano2002introduccion,joskowicz2008reglas}.

\subsection{Historias de Usuarios}

Las HU son la técnica que utiliza XP para especificar los requisitos de software, estas deben ser pro-
gramadas en un tiempo entre una y tres semanas. Si la estimación es superior a las tres semanas, debe ser
dividida en dos o más historias. Si es menos de una semana, se debe combinar con otra HU. Las estimaciones
de esfuerzo, asociado a la implementación de las historias, la establecen los programadores, utilizando como
medida el punto. Un punto, equivale a una semana ideal de programación (5 días laborables). Las historias,
generalmente, valen de 1 a 3 puntos. \citep{escribano2002introduccion}. A continuación se describen las HU definidas
parra llevar a cabo el desarrollo de los módulos.


\begin{userstory}[tb:prueba]
	\storyname{Registro de Usuario}
	\storyuser{Administrador, Usuario}
	\storyiter{1}
	\storypriority{Alta}
	\storyrisk{Bajo}
	\storypoints{2}
	\storyprogrammer{Técn. Carlos Brayan Rámila Chorens}
	\storydescription{
		Como usuario nuevo, quiero poder registrarme en la aplicación proporcionando mi información personal, como nombre, dirección de correo electrónico y contraseña, para acceder a las funcionalidades de la aplicación.
		\begin{itemize}
			\item nombre
			\item dirección de correo electrónico
			\item contraseña
			\item carnet de identidad
		\end{itemize}
	}
	\storyobservation{
		\begin{itemize}
			\item La aplicación debe permitir al usuario completar un formulario de registro con campos para nombre, correo electrónico y contraseña.
			\item Los campos del formulario deben validar que la información ingresada sea válida y esté en el formato correcto.
			\item Después de enviar el formulario, la aplicación debe crear una cuenta de usuario y almacenarla en la base de datos.
			\item Se debe enviar un correo electrónico de confirmación al usuario registrado para verificar su dirección de correo electrónico.
			\item El usuario debe poder iniciar sesión después de completar el registro exitosamente.
		\end{itemize}
		}
	%\storyinterface{\includegraphics[scale=0.5]{Images/DSC00461}}
\end{userstory}


\begin{userstory}[tb:prueba]
	\storyname{Iniciar Sesión}
	\storyuser{Administrador, Usuario}
	\storyiter{1}
	\storypriority{Alta}
	\storyrisk{Bajo}
	\storypoints{2}
	\storyprogrammer{Técn. Carlos Brayan Rámila Chorens}
	\storydescription{
		Como usuario registrado, quiero poder iniciar sesión en la aplicación utilizando mi dirección de correo electrónico y contraseña, para acceder a mis datos y realizar acciones dentro de la aplicación.
		\begin{itemize}
			\item dirección de correo electrónico
			\item contraseña
		\end{itemize}
	}	
	\storyobservation{
		\begin{itemize}
			\item La aplicación debe proporcionar un formulario de inicio de sesión con campos para correo electrónico y contraseña.
			\item Los campos del formulario deben validar que la información ingresada sea válida y coincida con los datos almacenados en la base de datos.
			\item Después de enviar el formulario, la aplicación debe autenticar al usuario y redirigirlo a la página principal si las credenciales son válidas.
			\item Si las credenciales son inválidas, la aplicación debe mostrar un mensaje de error al usuario indicando que las credenciales son incorrectas.
			\item La sesión del usuario debe mantenerse activa mientras navega por la aplicación, permitiéndole acceder a las funcionalidades protegidas sin necesidad de volver a iniciar sesión.
		\end{itemize}
	}
	%\storyinterface{\includegraphics[scale=0.5]{Images/DSC00461}}
\end{userstory}


\begin{userstory}[tb:prueba]
	\storyname{Gestión de Perfiles de Usuario}
	\storyuser{Administrador}
	\storyiter{1}
	\storypriority{Alta}
	\storyrisk{Bajo}
	\storypoints{1}
	\storyprogrammer{Técn. Carlos Brayan Rámila Chorens}
	\storydescription{
		Como administrador, quiero poder gestionar los perfiles de usuario, incluyendo la capacidad de crear, editar y eliminar cuentas de usuario, para mantener el control sobre quién tiene acceso a la aplicación.
		\begin{itemize}
			\item nombre
			\item dirección de correo electrónico
			\item contraseña
			\item carnet de identidad
		\end{itemize}
	}	
	\storyobservation{
		\begin{itemize}
			\item La aplicación debe proporcionar una interfaz de administración donde el administrador pueda ver una lista de todos los usuarios registrados.
			\item El administrador debe poder crear nuevos perfiles de usuario, proporcionando información como nombre, dirección de correo electrónico y contraseña.
			\item Se debe implementar la funcionalidad de edición para permitir al administrador actualizar la información de los perfiles de usuario existentes.
			\item El administrador debe poder eliminar cuentas de usuario cuando sea necesario, lo que resultará en la eliminación permanente de los datos asociados con esa cuenta.
			\item Se deben implementar controles de acceso adecuados para garantizar que solo el administrador tenga acceso a estas funcionalidades de gestión de perfiles.
		\end{itemize}
	}
	%\storyinterface{\includegraphics[scale=0.5]{Images/DSC00461}}
\end{userstory}

\subsection{Estimación de esfuerzo por Historia de Usuario}

Se realiza la estimación de esfuerzo que arroja cada HU, con el objetivo de obtener un correcto desarrollo
del sistema. Para una mayor organización se decide además, asignar a cada iteración el conjunto de historias
agrupadas en correspondencia con el módulo al que representen. A continuación se muestra la estimación
realizada:

\subsection{Desarrollo del plan de iteraciones}

Una vez definidas las HU y realizada una previa estimación de esfuerzos, se procede a la planificación de
la etapa de implementación del sistema. En este espacio, se crea el plan de iteraciones, donde se especifica
la prioridad con que se implementarán las HU organizadas por iteraciones. Teniendo en cuenta el esfuerzo
asociado a las HU y a las prioridades del cliente, se define una versión que sea de valor para este.

\begin{effortestimation}
	\addentry[4]{Graficar secuencias de ensamble}{1.1}  
	\addentry[3]{Determinar Secuencia de Ensamble}{2.5}  
	\addentry[2]{Graficar secuencias de ensamble}{0.3} 
	\addentry[2]{Graficar secuencias de ensamble}{0.3} 
	\addentry[2]{Graficar secuencias de ensamble}{0.2} 
	\addentry[2]{Graficar secuencias de ensamble}{0.2} 
	\addentry[1]{Cargar Fichero}{0.8} 
	\addentry[1]{Determinar Secuencia de Ensamble}{0.2} 
	\addentry[1]{Gestionar restricción cambios de herramienta}{0.5} 
	\addentry[1]{Esta es la prueba para el tinguiri}{0.5} 
\end{effortestimation}


\subsection{Plan de duración de las iteraciones}

A continuación, se presenta el plan de duración de las iteraciones. Este plan, tiene como finalidad, mostrar
la duración de cada iteración, así como el orden en que serán implementadas las HU en cada iteración como
se muestra en la tabla siguiente:

\geniterationplan

\subsection{Plan de entregas}

En el plan de entrega que se plantea a continuación, se hace una propuesta de las versiones (releases) del sistema. Cada versión se conformará al finalizar una iteración.

\section{Fase II: Diseño del sistema}

La plataforma se implementó siguiendo los principios del patrón arquitectónico MVT
La arquitectura Modelo-Vista-Template (MVT) es un patrón de arquitectura de software utilizado por Django. Es una variante del patrón Modelo-Vista-Controlador (MVC) y se caracteriza por tratar de desacoplar lo máximo posible la interfaz de usuario de la lógica de la aplicación.
El patrón MVT se divide en tres componentes principales:

\begin{itemize}
	\item Modelo: El modelo es responsable de manejar los datos y la lógica de negocio de la aplicación. En otras palabras, el modelo es el encargado de interactuar con la base de datos y proporcionar los datos necesarios a la vista.
	\item Vista: La vista es responsable de presentar los datos al usuario final. En otras palabras, la vista es el encargado de manejar las interfaces gráficas y proporcionar información dinámica al usuario.
	\item 	Plantilla: La plantilla es responsable de definir cómo se presentan los datos en la vista. En otras palabras, el template define cómo se estructura y se muestra la información en la GUI.
\end{itemize}

El patrón MVT es una arquitectura de diseño que se utiliza para crear aplicaciones web eficientes y escalables. La separación de responsabilidades en los componentes del patrón permite que cada uno cumpla una función clara y definida, lo que facilita su mantenimiento y escalabilidad en el futuro. La reutilización de código, ya que, al separar las diferentes responsabilidades en componentes individuales, el código se puede escribir una vez y reutilizar en diferentes partes de la aplicación. Esto reduce el tiempo y el costo del desarrollo, y hace que el proceso de programación sea más eficiente.


\section{Patrones de diseño}


Los patrones de diseño, tratan los problemas que se repiten y que se presentan en situaciones particulares
del diseño, con el fin de proponer soluciones a ellas. Se encargan de identificar clases, instancias, roles,
colaboraciones entres estas, así como la distribución de responsabilidades. En resumen,
es una descripción de clases y objetos comunicándose entre sí, adaptada para resolver un problema de diseño
general en un contexto particular.

\subsection{Patrones \ac{GRASP}}

\ac{GRASP} son un conjunto de patrones de diseño de software orientado a objetos que se enfocan en asignar responsabilidades de manera adecuada a las clases y objetos en un sistema. Los patrones de diseño \ac{GRASP} proporcionan un enfoque práctico para el diseño orientado a objetos y se pueden aplicar a diferentes etapas del ciclo de vida del software, desde la planificación hasta la implementación. Estos patrones de diseño pueden ayudar a mejorar el modularidad, la reutilización, la flexibilidad y la mantenibilidad del software, al tiempo que reducen la complejidad y el acoplamiento entre las clases.

Patrones de diseño \ac{GRASP}:

\begin{itemize}
	\item Controlador: maneja las solicitudes entrantes y enviar las respuestas correspondientes a los clientes. El controlador en Django se evidencia a través de una vista y en la configuración de las rutas URL, permitiendo una asignación efectiva de responsabilidades en la gestión de solicitudes y lógica de la aplicación. 
	\item Creador: Django utiliza Creator para crear objetos de modelo. ORM de Django se encarga de crear objetos de modelo y mapearlos a la base de datos. La creación de instancias es unas de las actividades más comunes en un sistema orientado a objetos. El patrón se hace evidente en las clases contenidas dentro del archivo View.py, las cuales tienen la responsabilidad de instanciar los objetos creados con cada sistema de configuración básica.
	\item Experto: Django utiliza Expert para asignar responsabilidades de manera adecuada a las clases. En Django, las vistas son responsables de manejar las solicitudes entrantes y las plantillas son responsables de generar las respuestas HTML. Este patron se encuentra aplicado en todas las clases del archivo Models.py.
	\item	Alta Cohesión: cada elemento del diseño debe realizar una labor única dentro del sistema, no desempeñada por el resto de los elementos y auto identificable. Este patrón está representado en las clases contenidas dentro del archivo View.py, las cuales tienen una única responsabilidad que puede ser CreateView, UpdateView o DeleteView.
	
\end{itemize}

\subsection{Patrones \ac{GoF}}

Los patrones de diseño \ac{GoF}) son un conjunto de patrones de diseño de software orientado a objetos. Estos patrones de diseño se han convertido en un conjunto clásico de patrones de diseño y son ampliamente utilizados en el diseño y desarrollo de sistemas de software orientados a objetos. Proporcionan soluciones probadas y efectivas para problemas comunes de diseño de software orientado a objetos. Cada patrón describe un problema de diseño específico y proporciona una solución general que se puede aplicar a diferentes situaciones.

Patrones de diseño \ac{GoF}:

\begin{itemize}
	\item Decorador: agrega funcionalidades adicionales a las vistas. Django utiliza este patrón para la creación de vistas personalizadas y middleware, permitiendo agregar funcionalidad adicional a las vistas o el procesamiento de solicitudes sin modificar su código principal como la autenticación, caché, compresión.
\end{itemize}


Una vez definidos los patrones de diseño, se describen las clases utilizadas en la solución. Siguiendo la metodología XP, se analizan las HU y se descomponen en tareas independientes.

\section{Tarjetas \ac{CRC}}

A continuación, las HU son evaluadas para dividirlas en tareas, cada tarea representa una característica distinta del sistema y se puede diseñar una prueba de unidad que verifique cada tarea, estas tareas se
representan por medio de las tarjetas \ac{CRC}.


\begin{figure}[!htb]
	\centering
	\captionbox{Prototipo de Tarjeta \ac{CRC}\label{fig:crc}}
	{\includegraphics[width=0.7\linewidth]{Images/crc}}
\end{figure}

Como se puede observar en la Figura 2.2, cada tarjeta contiene el nombre de la clase, una descripción de
las responsabilidades o métodos asociados con la clase, así como la lista de las clases con que se relaciona
o que colaboran con ella. A continuación se describen las tarjetas definidas para la implementación de la
solución.

\begin{crccard}[tb:mytable]
	\crcclass{RegistroUsuario}
	\crcresp{
		\begin{itemize}
			\item Recibir y validar la información del usuario para el registro.
			\item Almacenar la información del usuario en la base de datos.
			\item Enviar un correo electrónico de confirmación al usuario registrado.
		\end{itemize}
	}
	\crccolab{
		\begin{itemize}
			\item BaseDeDatos: para almacenar la información del usuario.
			\item ServicioDeCorreo: para enviar el correo electrónico de confirmación.
		\end{itemize}
	}
\end{crccard}


\begin{crccard}[tb:mytable]
	\crcclass{IniciarSesion}
	\crcresp{
	\begin{itemize}
		\item Autenticar al usuario utilizando su correo electrónico y contraseña.
		\item Mantener la sesión activa mientras el usuario navega por la aplicación.
		\item Redirigir al usuario a la página principal después de iniciar sesión correctamente.
	\end{itemize}
}
\crccolab{
	\begin{itemize}
		\item BaseDeDatos: para verificar las credenciales del usuario.
		\item InterfazDeUsuario: para mostrar mensajes de error en caso de credenciales incorrectas.
	\end{itemize}
}
\end{crccard}

\clearpage

\begin{crccard}[tb:mytable]
	\crcclass{GestionPerfilesUsuario}
	\crcresp{
	\begin{itemize}
		\item Mostrar una lista de todos los usuarios registrados.
		\item Permitir al administrador crear, editar y eliminar perfiles de usuario.
		\item Implementar controles de acceso para garantizar la seguridad de las operaciones de gestión de perfiles.
	\end{itemize}
}
\crccolab{
	\begin{itemize}
		\item BaseDeDatos: para acceder y actualizar la información de los perfiles de usuario.
		\item InterfazDeAdministrador: para mostrar la lista de usuarios y proporcionar opciones de edición y eliminación.
	\end{itemize}
}
\end{crccard}

\section{Conclusiones del capítulo}

En este capítulo se han abordado los aspectos referentes a la concepción del producto a desarrollar y sus
características funcionales. Esto permitió arribar a las siguientes conclusiones: